markdown preprocessor

Следует взять dotNut/dn_doc_gen, как базу.

Маркдаун хорош, но можно лучше.
Делаем препроцессор, чтобы было совсем пиздато.

Дауни, дауни, Роберт (Джей/мать твою) Маркдауни (мл). Кому как нравитсо.


1) следует сделать нумерацию разделов.
   Все строки, которые начинаются с # - это заголовки разделов (кроме спец. случаев)
   Штатные средства markdown не всегда умеют или хотят нумеровать разделы при рендеринге, но
   нумерация разделов - довольно удобная фича, поэтому наш препроцессор должен это уметь.

   Нужно уметь пропускать блоки кода, и не обрабатывать '#' в них - в сишечном/плюсовом коде, как минимум
   такие места могут встречаться.

   Нумерация разделов идёт последним пунктом после всего остального

2) Команда insert (или snippet, как в доксигене?).
   Начинается с символов '#$' ('#!') - если не используется препроцессор, то она будет оформлена, как заголовок верхнего уровня,
   что в общем-то, тоже неплохо.

   #$insert{опции} имя_файла_откуда#тэг_или_диапазон_строк
   или
   #!insert ? Знак вопрошения более информативен, если что-то пошло не так?

   Корень каталогов, откуда выкусываем сэмплы, задаётся опцией командной строки, и все файлы в insert задаются
   относительно этого корня. Вопрос, надо ли много корней, или он будет один?

   --set-samples-root
   или
   --add-samples-root
   ?

   Диапазон строк детектится просто - только цифры, и ровно один минус/дефис

   Если 
   #!insert{doc} bla-bla.md
   то поиск идёт только относительно текущего файла?
   Или для insert-doc отдельные пути поиска?

3) Задаём идентификаторы языка (ЯП) в листингах на базе расширений.

   В markdown в листингах можно явно указывать язык программирования, код которого приведён в листинге

   ```cpp
   // Тут какой-то плюсовый код
   ```

   При выкусывании сэмплов автоматом надо задавать тэг языка листинга на основании расширения файла. 
   Добавляем все расширения для плюсиков в базовом .options файле как-то так:

   --add-lang-file-extention=cpp,cpp
   --add-lang-file-extention=cpp,cxx
   --add-lang-file-extention=cpp,c++
   --add-lang-file-extention=cpp,cc
   --add-lang-file-extention=cpp,h
   --add-lang-file-extention=cpp,hpp
   --add-lang-file-extention=cpp,h++

4) Метки в сорцах для выкусывания фрагментов
   У доксигена - тупо парные, но я в dn_doc_gen делал возможность вложенных фрагментов, это имхо удобнее и полезнее.
   Для squirrel (он поддерживает сишные/плюсовые однострочные коменты) это выглядело так:
   //!#МЕТКА
   //!#

   Для плюсов - аналогично должно нормально работать

   При этом, если в выкусываемом фрагменте есть более мелкие помеченные для выкусывания фрагменты, то всё корректно выкусывается,
   а лишние спец-метки внутри могут удалятся, оставляться, как есть, или заменятся на пустые строки

   --set-cut-prefix=cpp,//!#
   --set-cut-prefix=nut,//!#

   Так задаём префиксы фрагментов выкусывания для разных языков.

5) В выходном маркдауни не всегда нужно добавлять суффикс ЯП (```cpp, иногда нужно просто ```)

   Опция инклюда в конкретном кейсе.

6) Опции

   Глобально опции выкуса задаем через командную строку, но можно переопределять их для отдельного выкуса.

   Для конкретного выкуса задаём их переопределение в курли брейсес:

     #!insert{lineno,notrim,notag} имя_файла_откуда#тэг_или_диапазон_строк

   Примеры опций:

     nolineno/lineno       - (не)добавлять номера строк выкусывемого файла. Полезно, когда мы хотим процитировать фрагмент чужого кода
     notrim/trim           - (не)оставить те же отсупы, что и в исходном файле. По умолчанию конечно же аплаится опция trim, но notrim оставлен для извращенцев
     notag/tag             - (не)добавлять тэг языка во вставляемом фрагменте к трем бэктикам листинга
     nofilename/filename   - (не)добавлять имя файла перед листингом
     nopath/path           - (не)указывать полный путь (указанный в команде insert), иначе - указывать только имя файла
     nofail/fail           - если произошел fail с включением стороннего фрагмента, то включаем исходную команду, на которой сйейлились
                             если указано nofail, то исходная команда не включается и ничего не происходит (аналог нового плюсового __if_exist в препроцессоре)

   Командная строка:

     --cut-options=lineno,notrim,notag

   Задаём глобально дефолтные настройки выкусывания.


7) Опции детальнее

   lineno, nolineno - включение/выключение вставки номеров строк в результирующем маркдауни
   trim,notrim,trimleft,notrimleft - выкусываемые фрагменты будут прижиматься к левому краю, или будет использован отступ из оригинального файла с семплами
   tag,notag,langtag,nolangtag - при вставке кода добавляем тэг языка (```cpp vs ```)
   filename,nofilename - перед вставкой фрагмента кода вставлять или не вставлять имя файла, откуда его выкусили. Имя файла будет вставлено, как указано в команде insert/snippet

   Примечание, не относящееся к текущему проекту
   У меня сложилась практика именования переменных, что что-то связанно с номерами я маркирую суффиксами No (от слова номер) - blaBlaNo/всяхерняNo. 
   По аглицки это вроде бы number и д.б. суффикс Nu.
   И я неоднократно был заклёван коллегами по этому и аналогичным поводам.
   Но вот вам шах и мат (chemate, worms) - doxygen \snippet{lineno} - https://www.doxygen.nl/manual/commands.html#cmdsnippet


8) Метки для заголовков

   Doxygen поддерживает нестандартное расширение маркдауна - метки для заголовков.
   На них потом можно ссылаться в тексте типа [бла-бла](#mysuperpupper)

   Выглядит это так:

     # Мой супер-пупер заголовок {#mysuperpupper}

   У нас есть тема, что каждый заголовок мы помечаем тэгом (как в стандарте C++ примерно) в квадратных скобках.

   При генерации маркдауна для доксигена мы можем делать немного найса:

    - если строка заголовка заканчивается на '}' - ничего не делаем ваще, какой-то идентификатор уже втюрен
    - если строка заголовка заканчивается на ']' - это наша система тэгов, генерим соответствующий доксмгеновский тэг {#}
    - если в заголовке нет никаких маркеров, то тут могут быть варианты:
      + ничего не генерить
      + генерить какой-то хэш
      + генерить транслит-метку
      + самый простой варик - ничего не генерить )

   GitHub (ПшеРги)
   https://gist.github.com/asabaylus/3071099?permalink_comment_id=3366191
   So, characters like á,é,í,ó,ú,Á,É,Í,Ó,Ú,Ñ,ñ are just omitted in anchors.
   #Definición (note the Spanish accent in the "o")
   [Ir a definición](#definicin)


9) Support for GitHub Alerts
https://www.doxygen.nl/manual/markdown.html#mddox_github_alerts
https://docs.github.com/ru/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#alerts


In the GitHub version of markdown there is the support for so called alerts, the syntax is similar to a one level block quote followied by [!<alert>] where <alert> can be one of note, warning, tip, caution or important. In doxygen these alerts are translated into normal doxygen commands:

    > [!note] is translated to \note
    > [!warning] is translated to \warning
    > [!tip] is translated to \remark
    > [!caution] is translated to \attention
    > [!important] is translated to \important

Example:
> [!note]
> The special text for the note


10) Коментарии
#// однострочный
#/* бла-бла
#*/
бла-бла #*/

Или многострочные не нужны?


11) Метаданные

    https://stackoverflow.com/questions/44215896/markdown-metadata-format
    https://jekyllrb.com/docs/front-matter/

    YAML metadata in Markdown - https://peterbabic.dev/blog/yaml-metadata-in-markdown/
    category, tags, slug, time or title

    https://fletcher.github.io/MultiMarkdown-5/metadata.html

    https://github.blog/2013-09-27-viewing-yaml-metadata-in-your-documents/

    GitHub Markup - https://github.com/github/markup
      https://github.com/github/markup?tab=readme-ov-file#markups
      https://github.com/github-linguist/linguist#syntax-highlighting

    https://python-markdown.github.io/extensions/meta_data/

12) Обработка метаданных
    1) Метадата всегда коллектится
       Метадата всегда обрезается, но если задано no-strip-metadata, то сколлекционированная метадата сериализуется.
       --processing-options=strip-metadata, --processing-options=no-strip-metadata
    2) Некоторые тэги - это списки, такие, как author
       Русское "Автор" транслитерируется в Avtor, надо уметь заменять на Autor, 
       чтобы можно было задавать тэги на русском.
    3) Надо обумать, как всё это разбирать



13) Генераторы сайтов на маркдауне

Transform your plain text into static websites and blogs - http://jekyllrb.com/
GitHub Pages. Websites for you and your projects - https://pages.github.com/

VSCode - https://github.com/mjbvz/vscode-github-markdown-preview


14) Опция --batch, позволяющая сканировать и обрабатывать пачки документов в пакетном режиме
    Сюда же include/exclude маски


15) Настройки храним также в корне проекта в файле .md-pp-config или .md-pp-options.
    Это обычные .options файл, по строчке на опцию.
    Корень проекта там, где лежит .md-pp-config.
    Для безопасности #!insert можно ограничивать только текущим проектом, запрет выходить за пределы корня


16) umba-md-pp-view - тулза, генерящая проект для доксигена, вызывающая его, затем открывающая сгенеренный файл.
    Временные файлы в %TEMP%\.umba-md-pp-view\$(FilenameHash)\
    Желательно открывать так, чтобы Word не лочил файл, но может не получится. Ну, или убивать может получится тот ворд, 
    в котором открыт текущий документ.


17) TOC - Table Of Content и ссылки на разделы.
    Самое хорошее правило - не ссылаться на разделы вообще, потому что разные системы могут генерить идентификаторы по-разному,
    мы не можем на это повлиять. В Doxygen'е есть возможность задавать ID раздела, а на GitHub'е - такой возможности нет.
    Надо проверить, потянет ли Doxygen ссылки на русском, согласно правилам гитхаба. Если потянет - то сделать одинаковые правила.
    Хотя, не получится - на гитхабе, если делаем нумерацию, то номер раздела попадает в ID, а это плохо.
    В общем, лучше совсем не ссылаться на разделы. Генерация идентификаторов нужна только для генерации TOC.

    Идея по ссылкам на разделы. Указываем в них просто текст заголовка - [Какой-то текст](#Просто полный текст заголовка)
    Также для каждого заголовка можно задать частично или полностью квалифицированную ссылку. Потом распарсим текст на предмет 
    ссылок и сделаем замену.




